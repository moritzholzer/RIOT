/*
 * SPDX-FileCopyrightText: 2026 HAW Hamburg
 * SPDX-License-Identifier: LGPL-2.1-only
 */

/**
 * @{
 *
 * @file
 * @author Moritz Holzer <moritz.holzer@haw-hamburg.de>
 */

#pragma once

#include "mutex.h"

#include "net/ieee802154/mac.h"
#include "net/ieee802154/mac_pib.h"

static inline uint8_t ieee80214_addr_len_from_mode(ieee802154_addr_mode_t mode)
{
    switch (mode) {
    case IEEE802154_ADDR_MODE_NONE:
        return 0;
    case IEEE802154_ADDR_MODE_SHORT:
        return IEEE802154_SHORT_ADDRESS_LEN;
    case IEEE802154_ADDR_MODE_EXTENDED:
        return IEEE802154_LONG_ADDRESS_LEN;
    default:
        return 0;
    }
}

/**
 * @brief IEEE 802.15.4 MAC thread event type.
 */
typedef enum {
    IEEE802154_MAC_EV_INIT,             /**< INIT event */
    IEEE802154_MAC_EV_REQ,
    IEEE802154_MAC_EV_RADIO_TX_DONE,    /**< TX done event */
    IEEE802154_MAC_EV_RADIO_RX_DONE,    /**< RX done event */
    IEEE802154_MAC_EV_RADIO_CRC_ERR,    /**< CRC error event */
    IEEE802154_MAC_EV_SUBMAC_BH,        /**< bootom half event */
    IEEE802154_MAC_EV_ACK_TIMEOUT,      /**< ACK timeout event */
    IEEE802154_MAC_EV_TX,               /**< wakeup event */
} ieee802154_mac_ev_t;

void ieee802154_init_mac_internal(ieee802154_mac_t *mac);

/**
 * @brief Attaches the IEEE 802.15.4 SubMAC callbacks.
 */
void ieee802154_mac_submac_attach(ieee802154_mac_t *mac);

/**
 * @brief Attaches the IEEE 802.15.4 SubMAC callbacks.
 */
void ieee802154_mac_tx_finish_current(ieee802154_mac_t *mac, int status);

/**
 * @brief Attaches the IEEE 802.15.4 Radio HAL callbacks.
 */
void ieee802154_mac_radio_attach(ieee802154_mac_t *mac);

void ieee802154_mac_tx(ieee802154_mac_t *mac, const ieee802154_ext_addr_t *dst_addr);

/**
 * @brief Whether the TX queue is full.
 */
static inline bool ieee802154_mac_tx_full(const ieee802154_mac_txq_t *txq)
{
    return txq->cnt >= IEEE802154_MAC_TXQ_LEN;
}

/**
 * @brief Whether the TX queue is empty.
 */
static inline bool ieee802154_mac_tx_empty(const ieee802154_mac_txq_t *txq)
{
    return (txq->cnt == 0);
}

/**
 * @brief Returns a descriptor of TX queue head. Caller fills it.
 */
static inline ieee802154_mac_tx_desc_t * ieee802154_mac_tx_reserve(ieee802154_mac_txq_t *txq)
{
    if (!txq || ieee802154_mac_tx_full(txq)) {
        return NULL;
    }

    ieee802154_mac_tx_desc_t *d = &txq->q[txq->tail];
    memset(d, 0, sizeof(*d));
    d->in_use = true;
    return d;
}

/**
 * @brief Advances TX queue tail to make it visible to the sender.
 */
static inline void ieee802154_mac_tx_commit(ieee802154_mac_txq_t *txq)
{
    txq->tail = (uint8_t)((txq->tail + 1) % IEEE802154_MAC_TXQ_LEN);
    txq->cnt++;
}

/**
 * @brief Returns descriptor of TX queue head (next to send), does not remove.
 */
static inline ieee802154_mac_tx_desc_t * ieee802154_mac_tx_peek(ieee802154_mac_txq_t *txq)
{
    if (!txq || ieee802154_mac_tx_empty(txq)) {
        return NULL;
    }

    ieee802154_mac_tx_desc_t *d = &txq->q[txq->head];

    if (!d->in_use) {
        return NULL;
    }

    return d;
}

/**
 * @brief Removes TX queue head entry.
 */
static inline void ieee802154_mac_tx_pop(ieee802154_mac_txq_t *txq)
{
    if (!txq || ieee802154_mac_tx_empty(txq)) {
        return;
    }

    ieee802154_mac_tx_desc_t *d = &txq->q[txq->head];
    memset(d, 0, sizeof(*d));

    txq->head = (uint8_t)((txq->head + 1) % IEEE802154_MAC_TXQ_LEN);
    txq->cnt--;
}

static inline int ieee802154_indirectq_alloc_slot(ieee802154_mac_indirect_q_t *indirect_q)
{
    if (indirect_q->free_mask == 0) {
        return -1;
    }

    /* first free slot */
    uint8_t slot = __builtin_ctz(indirect_q->free_mask);
    /* 0 means used */
    indirect_q->free_mask &= ~(1U << slot);
    return slot;
}

static inline void ieee802154_indirectq_free_slot(ieee802154_mac_indirect_q_t *indirect_q,
                                                  uint8_t slot)
{
    memset(&indirect_q->q[slot], 0, sizeof(ieee802154_mac_txq_t));
    indirect_q->free_mask |= (1U << slot);
}

static inline uint16_t ieee802154_indirect_get_deadline(ieee802154_mac_t *mac)
{
    ieee802154_pib_value_t value;

    ieee802154_mac_mlme_get(mac, IEEE802154_PIB_TRANSACTION_PERSISTENCE_TIME, &value);
    uint16_t unit_period_us =  value.v.u16 * mac->sym_us;
    /* round up to handle too early timeouts */
    uint16_t unit_period_ticks =
        (unit_period_us + IEEE802154_MAC_TICK_INTERVAL_US - 1U) / IEEE802154_MAC_TICK_INTERVAL_US;
    return (mac->indirect_q.tick + (unit_period_ticks * value.v.u16));
}

static inline bool ieee802154_mac_frame_is_expired(uint16_t now_tick, uint16_t deadline_tick)
{
    return (bool)((now_tick - deadline_tick) >= 0);
}

static inline void ieee802154_mac_handle_indirectq_auto_free(
    ieee802154_mac_indirect_q_t *indirect_q, uint8_t slot)
{
    ieee802154_mac_txq_t *txq = &indirect_q->q[slot];

    if (ieee802154_mac_tx_empty(txq)) {
        ieee802154_indirectq_free_slot(indirect_q, slot);
    }
    else {
        indirect_q->q[slot].deadline_tick =
            &ieee802154_mac_tx_peek(indirect_q->current_txq)->deadline_tick;
    }
}

static int _enqueue_data_tx(ieee802154_mac_t *mac,
                            uint8_t frame_type,
                            ieee802154_mac_txq_t *txq,
                            ieee802154_addr_mode_t src_mode,
                            ieee802154_addr_mode_t dst_mode,
                            const uint16_t *dst_panid,
                            const void *dst_addr,
                            iolist_t *msdu,
                            const uint8_t *msdu_handle,
                            bool ack_req,
                            bool indirect)
{
    ieee802154_mac_tx_desc_t *dsc = ieee802154_mac_tx_reserve(txq);

    dsc->handle = *msdu_handle;
    dsc->ack = ack_req;
    dsc->indirect = indirect;

    /* src addr selection */
    const void *src = NULL;
    ieee802154_pib_value_t src_v;
    if (src_mode == IEEE802154_ADDR_MODE_SHORT) {
        ieee802154_mac_mlme_get(mac, IEEE802154_PIB_SHORT_ADDR, &src_v);
        src = &src_v.v.short_addr;
    }
    else if (src_mode == IEEE802154_ADDR_MODE_EXTENDED) {
        ieee802154_mac_mlme_get(mac, IEEE802154_PIB_EXTENDED_ADDRESS, &src_v);
        src = &src_v.v.ext_addr;
    }

    uint8_t src_len = ieee80214_addr_len_from_mode(src_mode);
    uint8_t dst_len = ieee80214_addr_len_from_mode(dst_mode);
    ieee802154_pib_value_t src_panid;
    ieee802154_mac_mlme_get(mac, IEEE802154_PIB_PAN_ID, &src_panid);
    le_uint16_t src_pan = byteorder_btols(byteorder_htons(src_panid.v.u16));
    le_uint16_t dst_pan = byteorder_btols(byteorder_htons(*dst_panid));

    ieee802154_pib_value_t dsn;
    ieee802154_mac_mlme_get(mac, IEEE802154_PIB_DSN, &dsn);

    uint8_t flags = frame_type;
    if (ack_req) {
        flags |= IEEE802154_FCF_ACK_REQ;
    }

    size_t mhr_len = ieee802154_set_frame_hdr(dsc->mhr,
                                              src, (size_t)src_len,
                                              dst_len ? dst_addr : NULL, (size_t)dst_len,
                                              src_pan, dst_pan,
                                              flags,
                                              dsn.v.u8);
    if (mhr_len == 0 || mhr_len > (int)sizeof(dsc->mhr)) {
        dsc->in_use = false;
        return -EINVAL;
    }


    dsc->iol_msdu = msdu;
    dsc->iol_mhr.iol_base = &dsc->mhr;
    dsc->iol_mhr.iol_len = mhr_len;
    dsc->iol_mhr.iol_next = dsc->iol_msdu;

    /* DSN++ */
    ieee802154_pib_value_t dsn_new = {
        .type = IEEE802154_PIB_TYPE_U8,
        .v.u8 = dsn.v.u8 + 1,
    };
    uint16_t deadline = ieee802154_indirect_get_deadline(mac);
    dsc->deadline_tick = deadline;
    if (ieee802154_mac_tx_empty(txq)) {
        txq->deadline_tick = &dsc->deadline_tick;
    }
    ieee802154_mac_tx_commit(txq);
    ieee802154_mac_mlme_set(mac, IEEE802154_PIB_DSN, &dsn_new);
    return 0;
}

static inline int ieee802154_mac_indirectq_search_slot(ieee802154_mac_indirect_q_t *indirect_q,
                                                       const ieee802154_ext_addr_t *dst_addr)
{
    for (int i = 0; i < IEEE802154_MAC_TX_INDIRECTQ_SIZE; i++) {
        if (memcmp(indirect_q->q[i].dst_addr.uint8,
                   dst_addr->uint8,
                   IEEE802154_LONG_ADDRESS_LEN) == 0) {
            return i;
        }
    }
    return -1;
}

static inline int ieee802154_mac_indirectq_get_slot(ieee802154_mac_indirect_q_t *indirect_q,
                                                    const ieee802154_ext_addr_t *dst_addr)
{
    int slot = ieee802154_mac_indirectq_search_slot(indirect_q, dst_addr);

    if (slot >= 0) {
        return slot;
    }
    slot = ieee802154_indirectq_alloc_slot(indirect_q);
    indirect_q->q[slot].dst_addr = *dst_addr;
    return slot;
}



static inline int ieee802154_mac_map_push(ieee802154_mac_t *mac,
                                          uint8_t frame_type,
                                          ieee802154_addr_mode_t src_mode,
                                          ieee802154_addr_mode_t dst_mode,
                                          uint16_t *dst_panid,
                                          const void *dst_addr,
                                          iolist_t *msdu,
                                          const uint8_t *msdu_handle,
                                          bool ack_req,
                                          bool indirect)
{
    // TODO: mapping short to extended
    int slot = ieee802154_mac_indirectq_get_slot(&mac->indirect_q, dst_addr);
    int res = _enqueue_data_tx(mac, frame_type, &mac->indirect_q.q[slot], src_mode, dst_mode,
                               dst_panid, dst_addr, msdu, msdu_handle, ack_req, indirect);

    if (res < 0) {
        return res;
    }
    return 0;
}

static inline int ieee802154_mac_enqueue_data_request(ieee802154_mac_t *mac,
                                                      ieee802154_addr_mode_t dst_mode,
                                                      uint16_t *dst_panid,
                                                      const void *dst_addr)
{
    *(uint8_t *)mac->cmd.iol_base = IEEE802154_CMD_DATA_REQ;
    mac->cmd.iol_len = 1;
    mac->cmd.iol_next = NULL;
    // TODO: check for src addressing mode
    uint8_t handle = 0xFFU;
    ieee802154_mac_map_push(mac, IEEE802154_FCF_TYPE_MACCMD, dst_mode, dst_mode, dst_panid,
                            dst_addr, &mac->cmd, &handle, true, false);
    return 0;
}
